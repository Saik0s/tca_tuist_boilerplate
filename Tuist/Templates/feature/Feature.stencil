import ComposableArchitecture
import SwiftUI
import {{ name }}Interface

@Reducer
public struct {{ name }}Feature {
    @ObservableState
    public struct State: Equatable {
        var items: IdentifiedArrayOf<Item> = []
        var isLoading = false
        var sortOrder: SortOrder = .custom
        var filterCriteria: FilterCriteria?
        @Presents var destination: Destination.State?

        public init() {}
    }

    @Reducer(state: .equatable)
    public enum Destination {
        case add(AddItem)
        case edit(EditItem)
        case alert(AlertState<Action.Alert>)
    }

    public enum Action {
        case onAppear
        case itemsResponse(TaskResult<[Item]>)
        case addButtonTapped
        case destination(PresentationAction<Destination.Action>)
        case itemTapped(Item.ID)
        case moveItem(from: IndexSet, to: Int)
        case deleteItem(IndexSet)
        case setSortOrder(SortOrder)
        case setFilterCriteria(FilterCriteria?)

        public enum Alert: Equatable {
            case confirmDeletion(Item.ID)
        }
    }

    @Dependency(\.{{ name.charAt(0).toLowerCase() + name.slice(1) }}Client) var client

    public init() {}

    public var body: some ReducerOf<Self> {
        Reduce { state, action in
            switch action {
            case .onAppear:
                state.isLoading = true
                return .run { send in
                    await send(.itemsResponse(TaskResult { try await client.fetchItems() }))
                }

            case let .itemsResponse(.success(items)):
                state.isLoading = false
                state.items = IdentifiedArray(uniqueElements: items)
                return .none

            case .itemsResponse(.failure):
                state.isLoading = false
                state.destination = .alert(
                    AlertState(title: TextState("Error"), message: TextState("Failed to load items"))
                )
                return .none

            case .addButtonTapped:
                state.destination = .add(AddItem.State())
                return .none

            case let .destination(.presented(.add(.saveButtonTapped(item)))):
                state.items.append(item)
                state.destination = nil
                return .run { [items = state.items] send in
                    try await client.saveItems(Array(items))
                }

            case let .itemTapped(id):
                guard let item = state.items[id: id] else { return .none }
                state.destination = .edit(EditItem.State(item: item))
                return .none

            case let .destination(.presented(.edit(.saveButtonTapped(item)))):
                state.items[id: item.id] = item
                state.destination = nil
                return .run { [items = state.items] send in
                    try await client.saveItems(Array(items))
                }

            case let .moveItem(from, to):
                state.items.move(fromOffsets: from, toOffset: to)
                return .run { [items = state.items] send in
                    try await client.saveItems(Array(items))
                }

            case let .deleteItem(indexSet):
                let id = state.items[indexSet.first!].id
                state.destination = .alert(
                    AlertState {
                        TextState("Delete Item")
                    } actions: {
                        ButtonState(role: .destructive, action: .confirmDeletion(id)) {
                            TextState("Delete")
                        }
                        ButtonState(role: .cancel) {
                            TextState("Cancel")
                        }
                    } message: {
                        TextState("Are you sure you want to delete this item?")
                    }
                )
                return .none

            case let .destination(.presented(.alert(.confirmDeletion(id)))):
                state.items.remove(id: id)
                return .run { [items = state.items] send in
                    try await client.saveItems(Array(items))
                }

            case let .setSortOrder(order):
                state.sortOrder = order
                state.items.sort { lhs, rhs in
                    switch order {
                    case .alphabetical: return lhs.title < rhs.title
                    case .date: return lhs.createdAt < rhs.createdAt
                    case .custom: return true
                    }
                }
                return .none

            case let .setFilterCriteria(criteria):
                state.filterCriteria = criteria
                return .none

            case .destination:
                return .none
            }
        }
        .ifLet(\.$destination, action: /Action.destination) {
            Destination()
        }
    }
}

@Reducer
struct AddItem {
    @ObservableState
    struct State: Equatable {
        var item = Item(id: UUID(), title: "", description: "", createdAt: Date())
    }

    enum Action: Equatable {
        case setTitle(String)
        case setDescription(String)
        case saveButtonTapped(Item)
        case cancelButtonTapped
    }

    var body: some ReducerOf<Self> {
        Reduce { state, action in
            switch action {
            case let .setTitle(title):
                state.item.title = title
                return .none
            case let .setDescription(description):
                state.item.description = description
                return .none
            case .saveButtonTapped, .cancelButtonTapped:
                return .none
            }
        }
    }
}

@Reducer
struct EditItem {
    @ObservableState
    struct State: Equatable {
        var item: Item
    }

    enum Action: Equatable {
        case setTitle(String)
        case setDescription(String)
        case saveButtonTapped(Item)
        case cancelButtonTapped
    }

    var body: some ReducerOf<Self> {
        Reduce { state, action in
            switch action {
            case let .setTitle(title):
                state.item.title = title
                return .none
            case let .setDescription(description):
                state.item.description = description
                return .none
            case .saveButtonTapped, .cancelButtonTapped:
                return .none
            }
        }
    }
}
