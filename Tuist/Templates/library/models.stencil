import Foundation

public struct {{ name }}Item: Identifiable, Codable, Equatable {
  public let id: UUID
  public var title: String
  public var details: String
  public let createdAt: Date

  public init(
    id: UUID = UUID(),
    title: String,
    details: String,
    createdAt: Date = Date()
  ) {
    self.id = id
    self.title = title
    self.details = details
    self.createdAt = createdAt
  }
}

public enum {{ name }}Error: LocalizedError {
  case networkError(Error)
  case decodingError(Error)
  case unauthorized
  case notFound
  case unknown(Error)

  public var errorDescription: String? {
    switch self {
    case .networkError(let error): return "Network error: \(error.localizedDescription)"
    case .decodingError(let error): return "Decoding error: \(error.localizedDescription)"
    case .unauthorized: return "Unauthorized"
    case .notFound: return "Not found"
    case .unknown(let error): return "Unknown error: \(error.localizedDescription)"
    }
  }
}
import Foundation

// MARK: - Core Types

public struct TaskID: Hashable, Sendable {
  public let rawValue: UUID
  
  public init(_ rawValue: UUID = UUID()) {
    self.rawValue = rawValue
  }
}

public struct TaskInput: Sendable {
  public let priority: TaskPriority
  public let configuration: TaskConfiguration
  public let metadata: [String: String]
  
  public init(
    priority: TaskPriority = .normal,
    configuration: TaskConfiguration = .init(),
    metadata: [String: String] = [:]
  ) {
    self.priority = priority
    self.configuration = configuration
    self.metadata = metadata
  }
}

public struct TaskConfiguration: Sendable {
  public let retryCount: Int
  public let timeout: TimeInterval
  public let requiresNetwork: Bool
  
  public init(
    retryCount: Int = 3,
    timeout: TimeInterval = 300,
    requiresNetwork: Bool = true
  ) {
    self.retryCount = retryCount
    self.timeout = timeout
    self.requiresNetwork = requiresNetwork
  }
}

// MARK: - States & Events

public enum QueueState: Equatable {
  case idle
  case processing(activeCount: Int, pendingCount: Int)
  case paused(pendingCount: Int)
  case error(TaskError)
}

public enum QueueEvent: Equatable {
  case started
  case taskStarted(TaskID)
  case taskProgress(TaskID, TaskProgress)
  case taskCompleted(TaskID, TaskResult)
  case taskFailed(TaskID, TaskError)
  case paused
  case resumed
  case completed
  case failed(TaskError)
}

public struct TaskProgress: Equatable {
  public let completedUnits: Int
  public let totalUnits: Int
  public let currentPhase: TaskPhase
  public let estimatedTimeRemaining: TimeInterval?
  
  public var progress: Double {
    guard totalUnits > 0 else { return 0 }
    return Double(completedUnits) / Double(totalUnits)
  }
}

public struct TaskStatus: Equatable {
  public let id: TaskID
  public let state: State
  public let progress: TaskProgress?
  public let result: TaskResult?
  public let error: TaskError?
  
  public enum State: Equatable {
    case pending
    case processing
    case paused
    case completed
    case failed
  }
}

// MARK: - Supporting Types

public enum TaskPriority: Int, Comparable {
  case low = 0
  case normal = 1
  case high = 2
  case critical = 3
  
  public static func < (lhs: Self, rhs: Self) -> Bool {
    lhs.rawValue < rhs.rawValue
  }
}

public enum TaskPhase: Equatable {
  case preparing
  case processing(stage: Int, totalStages: Int)
  case finalizing
}

public struct TaskResult: Equatable {
  public let processedUnits: Int
  public let duration: TimeInterval
  public let metadata: [String: String]
}

public enum TaskError: LocalizedError, Equatable {
  case invalidInput
  case timeout
  case networkRequired
  case cancelled
  case resourceUnavailable
  case unknown(String)
  
  public var errorDescription: String? {
    switch self {
    case .invalidInput: return "Invalid input provided"
    case .timeout: return "Operation timed out"
    case .networkRequired: return "Network connection required"
    case .cancelled: return "Operation was cancelled"
    case .resourceUnavailable: return "Required resources unavailable"
    case .unknown(let message): return message
    }
  }
}
