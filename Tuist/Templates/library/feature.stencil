import ComposableArchitecture
import Foundation

@Reducer
public struct {{ name }}Feature {
  public struct State: Equatable {
    public var taskState: TaskState
    public var currentProgress: TaskProgress?
    public var configuration: TaskConfiguration
    @Presents public var alert: AlertState<Action.Alert>?
    
    public init(
      taskState: TaskState = .idle,
      currentProgress: TaskProgress? = nil,
      configuration: TaskConfiguration = .init()
    ) {
      self.taskState = taskState
      self.currentProgress = currentProgress
      self.configuration = configuration
    }
  }

  public enum Action {
    // User Actions
    case startButtonTapped
    case pauseButtonTapped
    case resumeButtonTapped
    case cancelButtonTapped
    case configurationUpdated(TaskConfiguration)
    
    // Internal Actions
    case taskEvent(TaskEvent)
    case taskProgress(TaskProgress)
    case taskStateChanged(TaskState)
    
    // Alert Actions
    case alert(PresentationAction<Alert>)
    
    public enum Alert: Equatable {
      case confirmCancel
    }
  }

  @Dependency(\.{{ name | lowercase }}Client) var client
  
  private enum CancelID {
    case task
    case progressObservation
    case stateObservation
  }

  public var body: some Reducer<State, Action> {
    Reduce { state, action in
      switch action {
      case .startButtonTapped:
        guard case .idle = state.taskState else { return .none }
        
        let input = TaskInput(configuration: state.configuration)
        
        return .merge(
          .run { send in
            for await event in await client.startTask(input) {
              await send(.taskEvent(event))
            }
          }
          .cancellable(id: CancelID.task),
          
          .run { [id = input.id] send in
            for await progress in await client.observeTaskProgress(id) {
              await send(.taskProgress(progress))
            }
          }
          .cancellable(id: CancelID.progressObservation),
          
          .run { [id = input.id] send in
            for await taskState in await client.observeTaskState(id) {
              await send(.taskStateChanged(taskState))
            }
          }
          .cancellable(id: CancelID.stateObservation)
        )

      case .pauseButtonTapped:
        guard case .running = state.taskState else { return .none }
        return .run { _ in try await client.pauseTask(input.id) }

      case .resumeButtonTapped:
        guard case .paused = state.taskState else { return .none }
        return .run { _ in try await client.resumeTask(input.id) }

      case .cancelButtonTapped:
        state.alert = AlertState {
          TextState("Are you sure you want to cancel the current task?")
        } actions: {
          ButtonState(role: .destructive, action: .send(.confirmCancel)) {
            TextState("Cancel Task")
          }
          ButtonState(role: .cancel) {
            TextState("Continue")
          }
        }
        return .none

      case .alert(.presented(.confirmCancel)):
        state.alert = nil
        return .merge(
          .cancel(id: CancelID.task),
          .cancel(id: CancelID.progressObservation),
          .cancel(id: CancelID.stateObservation),
          .run { _ in try await client.cancelTask(input.id) }
        )

      case .alert(.dismiss):
        state.alert = nil
        return .none

      case let .taskEvent(event):
        switch event {
        case .started:
          state.taskState = .running
        case .completed(let result):
          state.taskState = .completed(result)
          state.currentProgress = nil
        case .failed(let error):
          state.taskState = .failed(error)
          state.currentProgress = nil
        }
        return .none

      case let .taskProgress(progress):
        state.currentProgress = progress
        return .none

      case let .taskStateChanged(newState):
        state.taskState = newState
        return .none

      case let .configurationUpdated(configuration):
        state.configuration = configuration
        return .none
      }
    }
    .ifLet(\.$alert, action: \.alert)
  }
}
